%\documentclass[a4paper,fleqn,12pt]{article}
%\usepackage{graphicx,amsfonts,psfrag,fancyhdr,layout,appendix,subfigure}
%\usepackage[sectionbib]{natbib}
%\usepackage{chapterbib}
\newcommand{\rpm}{\raisebox{.2ex}{$\scriptstyle\pm$}}
\bgroup
\def\arraystretch{1.11}

\documentclass[journal,10pt]{IEEEtran} % fleqn (left aligns equations)
\usepackage{url}
\usepackage{float}

\usepackage{tabularx}
\usepackage{graphicx}

\usepackage{changepage}

\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{syntax}
\usepackage{mdwtab}
\usepackage{minted}

\usemintedstyle{vs} % visual studio style
\renewcommand\theFancyVerbLine{\footnotesize\arabic{FancyVerbLine}} % code line number size
\definecolor{bg}{rgb}{0.95,0.95,0.95} % code bg color


\markboth{Static JavaScript Call Graph Construction, June 2014}{}

\begin{document}

\setlength{\grammarindent}{6em}
\renewcommand{\syntleft}{}          % do not display '<' associated with variable, for example <A>
\renewcommand{\syntright}{}         % do not display '>' associated with variable, for example <A>


\title{Static JavaScript Call Graph Construction}
\author{Jorryt-Jan~Dijkstra \\ Software Engineering \\ Centrum~Wiskunde~\&~Informatica / University~of~Amsterdam \\ \texttt{jorryt-jan.dijkstra@student.uva.nl}}
\date{\today}

\maketitle

% \tableofcontents

%\begin{abstract}
%\end{abstract}

\section*{Preface}
Thank you coffee machine.

% Chapter 1.
% An introduction and overview of your thesis. Be sure to structure your thesis such that you do not have to repeat yourself later. In this section you do not cover details, but you give the reader an idea of the context, a brief overview of the research, and how the remainder of the thesis is structured.

% Chapter 2
% This section describes in detail what problem the research is addressing, and what the motivation is to address this problem.
% There is a concise and objective statement of the research questions (or hypotheses you are testing) and goals. It is made clear why these questions and goals are important and relevant to the outside world (i.e., the field of research or industry that you are addressing). You can already split the main research question into sub questions in this chapter.
% This section also describes an analysis of the problem: where does it occur and how, how often, and what are the consequences?
% An important part is also to scope to research: what aspects are included and what aspects are deliberately left out, and why?
% An example introduction can be found on Paul Klint?s homepage.

% Chapter 3
% This section describes the methods used to answer the research questions. A good structure of this section often follows the sub questions by providing a method for each.
% The research method can be based on the ?Scientific method?, but more creative solutions could be defined as well. In any case, the method needs a thorough motivation grounded in theory in order to be acceptable.
% As part of the method a number of hypotheses are described. These hypotheses will be tested by the research, using the methods described here.
% An important part of this section is validation. How will you evaluate and validate the outcomes of the research?
% You can look at Paul Klint?s homepage for examples of this section as well.

\section{Introduction}
\IEEEPARstart{C}{}all graphs are indispensable graphs for programming languages.
\section{Grammar}
Both call graph construction algorithms require a flow graph as input. This flow graph is constructed from a parse tree or abstract syntax tree. In order to get to such tree, a grammar had to be produced to parse JavaScript in the Rascal meta-programming language. This is due to Rascal being the programming language being developed at CWI. The language is used to carry out research. Therefore I invested approximately two months on creating a JavaScript grammar. The implementation of the grammar was led by the ECMAScript 5.1 (ECMA-262) specification of June 2011 \cite{ecmascriptspecs}. In this chapter, some of the common problems in JavaScript will be discussed.
\subsection{Automatic SemiColon Insertion}
JavaScript does not require semicolon's after each written statement. Semicolon's are one of the ways to mark separate statements. Line terminating characters are treated as a semicolon, in case the next non space character after the line break can not be interpreted as a continuation of the current statement \cite[p. 25]{flanagan2011javascript}. This is called \textit{automatic semicolon insertion}. The following characters are considered line terminating characters: \textit{carriage return}, \textit{line feed}, \textit{line separator}, \textit{paragraph separator} \cite[p. 15]{ecmascriptspecs}. The following sample code would result in declaring variable x with 7 due to automatic semicolon insertion:
\vskip 6pt
\begin{minted}[bgcolor=bg, linenos=true, frame=single, framerule=0.1pt, numbersep=8pt, fontsize=\small]{js}
var x = 1+
2
*3
\end{minted}
\vskip 6pt
A closing curly brace could also serve as terminating character for statements, provided that the code code is correct. Thus the brace should be closing a block. \\
Automatic semicolon insertion applies differently for \textit{return}, \textit{continue}, \textit{break}, \textit{throw} statements \cite[p. 26]{flanagan2011javascript} \cite[p. 26]{ecmascriptspecs}. A line terminating character after any of these keywords will be assumed to be the end of the statement. In the following example, the function invocation on line \#3 in the following code can be considered dead code:
\vskip 6pt
\begin{minted}[bgcolor=bg, linenos=true, frame=single, framerule=0.1pt, numbersep=8pt, fontsize=\small]{js}
function f() {
    return
    g(10);
}
\end{minted}
\vskip 6pt
Furthermore postfix operators require to be on the same line as the its operand \cite[p. 27]{ecmascriptspecs}. Therefore \textit{++} and \textit{--} operators on a separate line, are not considered postfix operators for its previous connected operand, but prefix operators for its connected operand ahead.
If JavaScript can not be parsed, the parser will insert a semicolon at the end of the input stream \cite[p. 27]{ecmascriptspecs}. \\
The grammar that has been developed as a prerequisite of this research, takes automatic semicolon insertion into account for closing braces and linefeeds. It also recognizes the four exceptional statements with the alternative semicolon insertion. % it still has to have other terminating chars and semicolon insertion @ EOF when it does not parse

\section{Flow Graph}
The original call graph algorithms rely on abstract syntax trees (ASTs) as an input. These trees are processed to create flow graphs from. Flow graphs track intraprocedural and interprocedural flow. Both call graph algorithms rely on these flow graphs and both have a different approach of connecting functions to function calls, using the flow graphs information. 
The prerequisite JavaScript grammar has been used to parse existing JavaScript files to parse trees. The conversion of parse tree to abstract syntax trees has been skipped, because the parse trees contain the same relevant information as ASTs for both call graph algorithms. \\
This paragraph will explain what the required flow graph entails and how it is obtained using a parse tree as input.

\subsection{Intraprocedural flow}
Intraprocedural analysis deals with the statements or basic blocks of a single procedure and with transfers of control between them \cite[p. 3]{Marlowe:1990aa}. This analysis will be done before the interprocedural analysis. Several rules originating from Sch\"{a}fer et al. lead to an intraprocedural flow graph \cite[p. 5]{Feldthaus:2013}. Note that the nodes being visited are nodes in the parse tree, which are all unique locations within the parse tree.

\begin{figure}[H]
\hspace*{-.4cm}
\scalebox{0.95}{
\begin{tabular}[l]{l | l | l}
& \textbf{node at} $\pi$ & \textbf{edges added when visiting} $\pi$ \\
\hline \\ [-2.5ex]
R1 & $l$ = $r$ & $V(r) \to V(l)$, $V(r) \to$ \textbf{Exp}($\pi$) \\
R2 & $l$ $||$ $r$ & $V(l) \to$ \textbf{Exp}($\pi$), $V(r) \to$ \textbf{Exp}($\pi$) \\
R3 & $t$ ? $l$ : $r$ & $V(l) \to$ \textbf{Exp}($\pi$), $V(r) \to$ \textbf{Exp}($\pi$) \\
R4 & $l$ \&\& $r$ & $V(r) \to$ \textbf{Exp}($\pi$) \\
R5 & \{$f$: $e$\} & $V(e_i) \to$ \textbf{Prop}($f_i$) \\
R6 & function expression & \textbf{Fun}($\pi$) $\to$ \textbf{Exp}($\pi$) \\ & & if it has a name: \textbf{Fun}($\pi$) $\to$ \textbf{Var}($\pi$) \\
R7 & function declaration & if it is in scope: \textbf{Fun}($\pi$) $\to$ \textbf{Var}($\pi$) \\ & & if it is global: \textbf{Fun}($\pi$) $\to$ \textbf{Prop}($\pi$) \\
\end{tabular}
}
\caption{Rules for creating intraprocedural edges for the flow graph, based on parse tree nodes}
\end{figure}

A different edge is added for function declarations in global scope (R7), in order to handle function declarations in global scope. This is not documented by Sch\"{a}fer et al., but it is assumed that they had this intraprocedural edge in their specification as well. This edge is necessary in order to provide a more complete call graph, which will be explained more in depth in section X. \\ %TODO refer to section 

The basic set of intraprocedural vertices consists of four different types:
\vspace{0.5em}
\begin{grammar}
<$V$> ::= \textbf{Exp($\pi$)} \grammarlabel{expression at position $\pi$}
\alt \textbf{Var($\pi$)} \grammarlabel{variable declared at position $\pi$}
\alt \textbf{Prop($f$)} \grammarlabel{property of name $f$}
\alt \textbf{Fun($\pi$)} \grammarlabel{function declaration/expression at $\pi$}
\end{grammar}

\vspace{0.5em}

The $V$ function as referred to in figure 1, represents a function that maps expressions to corresponding flow graph vertices:
\begin{equation*}
  V(t^\pi) = \begin{cases}
    \hspace*{0.2cm} \textbf{Var($\pi'$)} & \text{if~} t \equiv x \text{~and~} \lambda(\pi, x) = \pi' \\
    \hspace*{0.2cm} \textbf{Prop($\pi$)} & \text{if~} t \equiv x \text{~and~} \lambda(\pi, x) = undefined\\
    \hspace*{0.2cm} \textbf{Prop($f$)} & \text{if~} t \equiv e.f \\
    \hspace*{0.2cm} \textbf{Exp($\pi$)} &\text{otherwise}
  \end{cases}
\end{equation*}


The mapping function $V$ is dependent on a symbol map. This symbol map stores which variables are declared at which position in the local scope.

\subsection{Scoping}
Scoping is important for the mapping function $V$ which uses $\lambda(\pi, x)$ to find local variable $x$ for position $\pi$. An accurate variable lookup implies a more accurate flow graph. \\ % todo better explanation 
% TODO: is the var keyword unnecessary for global variables?
Scope in a programming language controls the visibility and lifetimes of variables and parameters \cite[p. 36]{Crockford:2008:JGP}. JavaScript has two types of scoping. It has a \textit{global} scope, which means that a global variable is defined everywhere in your JavaScript code. The second type of scoping in JavaScript is limited to the scope of a function. Variables declared within a functions are only defined within a functions body. These are called local variables and also entail the function its parameters \cite[p.53]{flanagan2011javascript}. Therefore this scope is known as \textit{local} scope. Even though JavaScript does support block syntax, it does not contain block scoping \cite[p. 36]{Crockford:2008:JGP}.
For creating the flow graph these two types of scopes have been taken into account. Because the lookup function for the flow graph algorithm solely looks up local variables, global variables are not stored in the symbol map. These will always be resolved to \textit{Prop} vertices by function $V$.

\subsubsection{Hoisting}
An important feature of the JavaScript scope is called \textit{hoisting}. This feature implies that variable declarations are hoisted to the top of the corresponding scope \cite[p. 54]{flanagan2011javascript}. Therefore declaring a variable anywhere in a scope, is equal to declaring it at the top of the scope \cite{mozillavarspecs}. Variables that are not yet initialized but are hoisted, will be considered undefined until they are initialized. Hoisting has been taken into account in order to refer to the correct position with mapping function $V$ in the flow graphs. Due to hoisting support the reference to variable $x$ on line \#3 will refer to the declaration on line \#4 rather than line \#1:
\vskip 6pt
\begin{minted}[bgcolor=bg, linenos=true, frame=single, framerule=0.1pt, numbersep=8pt, fontsize=\small]{js}
var x = 3;
function f() {
    console.log(x);
    var x = 20;
}
\end{minted}
\vskip 6pt

\subsubsection{Overriding}
Global variables are defined through the program, whereas local variables are defined through its enclosing function and nested functions \cite[p. 55]{flanagan2011javascript}. Variables on the scope can be redeclared within functions in the nested scope, whereas redeclaration of a variable in the same scope is ignored in JavaScript. This can also be done by providing a parameter with the same name, so that the previous variable is overridden within the nested scope. \\
Function names are also variables, and can be overridden like any other variable, within nested scopes. In addition to this rule, a function name on the scope can be overridden within its own parameters. The following example of function $f$ clarifies this:
\vskip 6pt
\begin{minted}[bgcolor=bg, linenos=true, frame=single, framerule=0.1pt, numbersep=8pt, fontsize=\small]{js}
(function f(f) {
    return f;
})(10);
\end{minted}
\vskip 6pt
The sample code will return 10, due to the overriding of function name $f$ within its scope. \\
Overriding of variables has been adopted to the flow graph creation algorithm, so that mapping function $V$ will benefit from the most accurate variable references. % TODO: reformulate sentence
\section{Call Graph Forms}


\section{Data}

\section{Threats to validity}
\subsection{Javascript Grammar}
Both JavaScript call graph algorithms require a parse tree as input. Code analysis at the CWI is often done with the Rascal meta-programming language, which provides a toolset that could help to ease the implementation of the algorithms. Rascal did not provide a JavaScript grammar to create a parse tree of a given JavaScript. Therefore creating a Rascal grammar for JavaScript interpretation was a prerequisite for the research project. The Rascal grammar seems to parse the given input scripts correctly and has been tested with unit tests with various snippets. Even though the grammar is thoroughly tested, it is possible that some deviations of the EcmaScript specification remain.
Due to the limited time (\rpm8 weeks) and all input scripts parsing successfully (that have been used to analyze the algorithms), the grammar has been considered good enough. I do not consider the impact of these possible deviations to be significant, but this could explain the difference between the output data of this paper and the previous research by Schafer et al. % TODO reference
The considered deviation(s) that might occur, would impact the algorithms, as input could be incorrect or incomplete. This would affect the flow graphs that were used to extract call graphs from.

\subsection{Interpretation}
Several things have been unclear in the specification of the two algorithms by Schafer et al. An example is the flow graph creation rule for \textit{function declarations} {\textbf{R7}). The algorithm does not seem to distinguish global function declarations from in-scope ones (functions that are declared in the scope of another function). The rule specifies function declarations to be added to the flow graph in the following form:
$$Fun(\pi) \to Var(\pi)$$
The original specification considers a lookup function for local variables, which is mentioned as follows:
\begin{quote}
We assume a lookup function $\lambda$ for local variables such that $\lambda(\pi, x)$ for a position $\pi$ and a name $x$ returns the position of the local variable or parameter declaration (if any) that $x$ binds to at position $\pi$. % TODO reference
\end{quote}
In case a global function declaration would also be considered as a Var vertex, it would need to be added the symbol table, which does not comply the definition of the lookup function that only considers local variables. Ignoring this would result in not resolving global function declaration $f$ through a transitive closure in both the algorithms. In case both the vertices in the function declaration and the function call would result in the same Vertex, the algorithm could determine where and which global function would be called, through the transitive closure. \\
As a successive script, that would essentially implement the same algorithm (according to Schafer), considers globally declared functions as Prop vertices, I have chosen to implement this similarly. This decision could be a reason of the deviation between the results of this paper and those of the earlier paper by Schafer et al. It is unclear whether this same decision has been implemented the same way as in the successive script, because the aforementioned specification does not mention so.

\bibliographystyle{IEEEtran}
\bibliography{references}
\end{document}